---
title: "Daily aggregations-coninuation of TA vs. Direct"
author: "Bahman Rostami-Tabar and Dejan Mircetic"
date: "June 17, 2020"
output: html_document
params:
     criteria: "MAPE"
     level   : "Annual"
---
```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(warning=FALSE)
knitr::opts_chunk$set(message=FALSE)
```

```{r libraries}
time_0<-Sys.time()
library(M4comp2018)
library(thief)
library(forecast)
library(abind)
library(ROSE)
library(performanceEstimation)
library(dplyr)
library(car)
library(tsfeatures)
```

```{r M4 data}
Daily_M4 <- Filter(function(l) l$period == "Daily", M4)
```

#Adding the accuracy function
```{r}
source("extended_accuracy.R")
source("forecasthorizont.R")
```

```{r}
aggdaily <- function (y, m = frequency(y), align = c("end", "start"), 
          aggregatelist = NULL) 
{
  #browser()
  align <- match.arg(align)
  n <- length(y)
  m <- as.integer(m)
  mout <- seq_len(m)
  mout <- mout[m%%mout == 0L]
  if(m==365){
    mout <- c(1,7,30,90,182,365)
  }
  mout <- mout[mout <= n]
  if (length(mout) == 0L) 
    stop("Series too short for aggregation")
  if (!is.null(aggregatelist)) 
    mout <- mout[mout %in% aggregatelist]
  if (length(mout) == 0L) 
    stop("No valid factors in aggregatelist argument")
  k <- length(mout)
  y.out <- vector("list", k)
  y.out[[1L]] <- y
  if (!is.ts(y)) 
    y <- ts(y, frequency = m)
  for (i in seq_len(k)[-1L]) {
    if (align == "end") 
      start <- n%%mout[i] + 1L
    else start <- 1L
    nk <- trunc(n/mout[i])
    tmp <- matrix(y[start - 1L + seq_len(mout[i] * nk)], 
                  ncol = nk)
    y.out[[i]] <- ts(colSums(tmp), frequency = round(m/mout[i]), 
                     start = tsp(y)[1] + (start - 1)/m)
  }
  names(y.out) <- paste("Period", m/mout)
  
  if (m == 4L) {
    names(y.out)[mout == 4L] <- "Annual"
    names(y.out)[mout == 2L] <- "Biannual"
    names(y.out)[mout == 1L] <- "Quarterly"
  }
  
  else if (m == 365) {
    names(y.out)[mout == 365L] <- "Annual"
    names(y.out)[mout == 182L] <- "Biannual"
    names(y.out)[mout == 90L] <- "Quarterly"
    names(y.out)[mout == 30L] <- "Monthly"
    names(y.out)[mout == 7L] <-"Weekly"
    names(y.out)[mout == 1L] <- "Daily"
  }
  else if (m == 12L) {
    names(y.out) <- paste(mout, "-Monthly", sep = "")
    names(y.out)[mout == 12L] <- "Annual"
    names(y.out)[mout == 6L] <- "Biannual"
    names(y.out)[mout == 3L] <- "Quarterly"
    names(y.out)[mout == 1L] <- "Monthly"
  }
  else if (m == 7L) {
    names(y.out)[mout == 7L] <- "Weekly"
    names(y.out)[mout == 1L] <- "Daily"
  }
  else if (m == 24L | m == 168L | m == 8760L) {
    names(y.out) <- paste(mout, "-Hourly", sep = "")
    j <- mout%%24L == 0L
    names(y.out)[j] <- paste(mout[j]/24L, "-Daily", 
                             sep = "")
    j <- mout%%168L == 0L
    names(y.out)[j] <- paste(mout[j]/168L, "-Weekly", 
                             sep = "")
    j <- mout%%8760L == 0L
    names(y.out)[j] <- paste(mout[j]/8760L, "-Yearly", 
                             sep = "")
    names(y.out)[mout == 8760L] <- "Annual"
    names(y.out)[mout == 2190L] <- "Quarterly"
    names(y.out)[mout == 168L] <- "Weekly"
    names(y.out)[mout == 24L] <- "Daily"
    names(y.out)[mout == 1L] <- "Hourly"
  }
  else if (m == 48L | m == 336L | m == 17520L) {
    j <- mout%%2L == 0L
    names(y.out)[j] <- paste(mout[j]/2L, "-Hourly", 
                             sep = "")
    j <- mout%%48L == 0L
    names(y.out)[j] <- paste(mout[j]/48L, "-Daily", 
                             sep = "")
    j <- mout%%336L == 0L
    names(y.out)[j] <- paste(mout[j]/336L, "-Weekly", 
                             sep = "")
    j <- mout%%17520L == 0L
    names(y.out)[j] <- paste(mout[j]/17520L, "-Yearly", 
                             sep = "")
    names(y.out)[mout == 17520L] <- "Annual"
    names(y.out)[mout == 4380L] <- "Quarterly"
    names(y.out)[mout == 336L] <- "Weekly"
    names(y.out)[mout == 48L] <- "Daily"
    names(y.out)[mout == 2L] <- "Hourly"
    names(y.out)[mout == 1L] <- "Half-hourly"
  }
  else if (m == 52L) {
    names(y.out) <- paste(mout, "-Weekly", sep = "")
    names(y.out)[mout == 52L] <- "Annual"
    names(y.out)[mout == 26L] <- "Biannual"
    names(y.out)[mout == 13L] <- "Quarterly"
    names(y.out)[mout == 1L] <- "Weekly"
  }
  return(structure(y.out, class = "tsaggregates"))
}
```


```{r Forecasting}
source("Daily aggregation/foresee3.R")

dailyTA<-foresee3(Daily_M4,model="TA")
dailyBase<-foresee3(Daily_M4,model="base")

TA <- dailyTA
Direct <- dailyBase
```

```{r Error plots}
#MAPE

min1 <- min(colMeans(Direct$Errors[,"MAPE",],na.rm = TRUE))
max1 <- max(colMeans(Direct$Errors[,"MAPE",],na.rm = TRUE))
min2 <- min(colMeans(TA$Errors[,"MAPE",],na.rm = TRUE))
max2 <- max(colMeans(TA$Errors[,"MAPE",],na.rm = TRUE))

min <- min(c(min1,min2));max <- max(c(max1,max2))

plot(colMeans(TA$Errors[,"MAPE",]), type = "b", ylab="MAPE", ylim=c(min,max))
points(colMeans(Direct$Errors[,"MAPE",]),type = "b", col="red")

#MASE

min1 <- min(colMeans(Direct$Errors[,"MASE",],na.rm = TRUE))
max1 <- max(colMeans(Direct$Errors[,"MASE",],na.rm = TRUE))
min2 <- min(colMeans(TA$Errors[,"MASE",],na.rm = TRUE))
max2 <- max(colMeans(TA$Errors[,"MASE",],na.rm = TRUE))

min <- min(c(min1,min2));max <- max(c(max1,max2))

plot(colMeans(TA$Errors[,"MASE",],na.rm = TRUE), type = "b", ylab="MASE",ylim=c(min,max))
points(colMeans(Direct$Errors[,"MASE",],na.rm = TRUE), type = "b", col="red")
```

#Comparison
```{r}
criteria <- params$criteria #RMSE, MASE, ...
level <- params$level #####"Monthly","2-Monthly","Quarterly","4-Monthly","Biannual","Annual"
#level <- "Quarterly"
```

```{r Comparison}

comparison <- function(criteria,level,TA,Direct){
  
  data<-cbind(TA$Errors[,criteria,level], Direct$Errors[,criteria,level])
  data<-cbind(data,c(rep(NA,dim(data)[1])))
  colnames(data)<-c("TA","Direct",criteria)
  data <- as.data.frame(data)
 
  BA <- rep(NA,dim(data)[1])

  for(i in 1:dim(data)[1]){
  
   ifelse(as.vector(data[i,1] < data[i,2]),BA[i] <- c("TA"),BA[i] <- c("Direct"))
  }
  data[,3] <-BA
  data[,3] <- as.factor(data[,3])
  
  return(data)
}
comp_data <- comparison(criteria,level,TA,Direct)
```

NE VALJAJU OSOBINE SAD TREBAJU OSOBINE ZA DAILY DATA!

```{r}
N <- dim(TA$Forecasts)[1] 
Mseries<-list(rep(NA,N))
series_names<-c(rep(NA,N))

for(k in(1:N)){
  Mseries[[k]]<-Daily_M4[[k]]$x
  series_names[k]<-Daily_M4[[k]]$st
}
names(Mseries)<-series_names

features<-tsfeatures(Mseries)
```

```{r}
marks <- comp_data[,criteria]

#marks <- ifelse(marks=="TA",1,0)
```

#Add characteristics
```{r Importing the features-time series characteristics}
characteristics <- features

metrics<-data.frame(characteristics); colnames(metrics)<-c(colnames(characteristics))
metrics<-metrics[,-c(1,2,3)];metrics<-scale(metrics)
```

```{r}
ClassTable<-as.data.frame(cbind(metrics,marks))

ClassTable[,"marks"] <- ifelse(ClassTable[,"marks"]==1,"Direct","TA")
ClassTable[,"marks"] <- as.factor(ClassTable[,"marks"])

attach(ClassTable)

set.seed(1)# Igraj se sa ovim set seed za vrijednost 5 daje peak da je znacajan a ne entropija.
train=sample(1:dim(ClassTable)[1],dim(ClassTable)[1]*0.7)

train.data<-ClassTable[train,]
test.data<-ClassTable[-train,]
```

#Logistic regression
```{r Logistic regression}

#Najbolji model
lr<-glm(marks~.,family = binomial, data=train.data);summary(lr);vif(lr)

#High leverage points
plot(hatvalues(lr))

lr.probs=predict(lr,type="response",newdata=ClassTable[-train,])
#contrasts(ClassTable[,"marks"])
```

#Choosing the treshold
```{r}
source("cutoff.R")
cut <- cutoff(lr.probs)
```

#Best performance of LR
```{r Best LR}
i<-cut
lr.pred=ifelse(lr.probs>i,"TA","Direct")
t<-table(lr.pred,ClassTable[-train,"marks"]);print(t)
(t[1,2]/(t[1,2]+t[2,2]))#FN
(t[2,1]/(t[1,1]+t[2,1]))#FP
mean(lr.pred==ClassTable[-train,"marks"])
```